{
  "version": 3,
  "sources": ["../../src/tools/get-environment-variables.ts", "../../src/vercel.ts"],
  "sourcesContent": ["import { fetchEnvironmentVariables } from \"../vercel\";\n\ntype Input = {\n  projectId: string;\n  teamId: string;\n};\n\nexport default async function getEnvironmentVariables({ projectId, teamId }: Input) {\n  return fetchEnvironmentVariables(projectId, teamId);\n}\n", "import { environment, getPreferenceValues, showToast, Toast } from \"@raycast/api\";\nimport type {\n  Team,\n  Deployment,\n  Project,\n  Environment,\n  User,\n  CreateEnvironmentVariableResponse,\n  Build,\n  Pagination,\n  CreateEnvironment,\n  Domain,\n} from \"./types\";\n\nexport const token = getPreferenceValues().accessToken;\nconst headers = {\n  Authorization: \"Bearer \" + token,\n};\n\nexport const FetchHeaders = Object.entries(headers);\n\nconst apiURL = \"https://api.vercel.com/\";\n\n// Fetch the username that belongs to the token given.\n// Use for filtering deployments by user and providing links later on\nexport async function fetchUser(): Promise<User> {\n  try {\n    const response = await fetch(apiURL + \"www/user\", {\n      method: \"get\",\n      headers: headers,\n    });\n\n    const json = (await response.json()) as { user: User };\n\n    return json.user;\n  } catch (err) {\n    console.error(err);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to fetch user info\",\n    });\n    throw new Error(\"Failed to fetch user info\");\n  }\n}\n\n/*\n * Fetch all teams for user\n */\nexport async function fetchTeams(): Promise<Team[]> {\n  const response = await fetch(apiURL + \"v1/teams\", {\n    method: \"get\",\n    headers: headers,\n  });\n  const json = (await response.json()) as { teams: Team[] };\n  const teams: Team[] = [];\n  for (const team of json.teams) {\n    teams.push(team);\n  }\n  return teams;\n}\n\nexport async function deleteProjectById(projectId: Project[\"id\"], teamId?: Team[\"id\"]) {\n  try {\n    const response = await fetch(apiURL + `v8/projects/${projectId}?teamId=${teamId ?? \"\"}`, {\n      method: \"delete\",\n      headers: headers,\n    });\n    const json = (await response.json()) as { project: Project };\n    return json.project;\n  } catch (e) {\n    console.error(e);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to delete project\",\n    });\n    throw new Error(\"Failed to delete project\");\n  }\n}\n\nexport async function deleteEnvironmentVariableById(\n  projectId: Project[\"id\"],\n  envId: Environment[\"id\"],\n): Promise<Environment> {\n  try {\n    const response = await fetch(apiURL + `v8/projects/${projectId}/env/${envId}`, {\n      method: \"delete\",\n      headers: headers,\n    });\n    const json = (await response.json()) as { environment: Environment };\n    return json.environment;\n  } catch (e) {\n    console.error(e);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to delete environment variable\",\n    });\n    throw new Error(\"Failed to delete environment variable\");\n  }\n}\n\nexport function getFetchDeploymentsURL(teamId?: string, projectId?: string, limit = 100) {\n  const url = apiURL + `v6/deployments`;\n\n  let query = `?limit=${limit}&teamId=${teamId ?? \"\"}`;\n  if (projectId) {\n    query += `&projectId=${projectId}`;\n  }\n\n  return url + query;\n}\n\nexport async function fetchDeployments(teamId?: string, limit = 100, maxToFetch = 300) {\n  try {\n    const fetchURL = getFetchDeploymentsURL(teamId, undefined, limit);\n    const response = await fetch(fetchURL, {\n      method: \"get\",\n      headers: headers,\n    });\n    const json = (await response.json()) as { deployments: Deployment[]; pagination: Pagination };\n\n    // eslint-disable-next-line prefer-const\n    let { deployments, pagination } = json;\n\n    while (pagination?.next && deployments.length < maxToFetch) {\n      const next = await fetch(fetchURL + \"&until=\" + pagination.next, {\n        method: \"get\",\n        headers: headers,\n      });\n      const nextJson = (await next.json()) as { deployments: Deployment[]; pagination: Pagination };\n      pagination = nextJson.pagination;\n      json.deployments.push(...nextJson.deployments);\n    }\n\n    return json.deployments;\n  } catch (err) {\n    console.error(err);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to fetch deployments\",\n    });\n    throw new Error(\"Failed to fetch deployments\");\n  }\n}\n\nexport function getFetchDeploymentBuildsURL(\n  deploymentId: Deployment[\"uid\"] | string,\n  teamId?: Team[\"id\"],\n  limit = 100,\n) {\n  return apiURL + `v11/deployments/${deploymentId}/builds?limit=${limit}&teamId=${teamId ?? \"\"}`;\n}\n\nexport async function fetchDeploymentBuildsByDeploymentId(deploymentId: string, teamId?: string, limit?: number) {\n  try {\n    const response = await fetch(getFetchDeploymentBuildsURL(deploymentId, teamId, limit), {\n      method: \"get\",\n      headers: headers,\n    });\n    const json = (await response.json()) as { builds: Build[] };\n    return json.builds;\n  } catch (err) {\n    console.error(err);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to fetch deployment builds\",\n    });\n    throw new Error(\"Failed to fetch deployment builds\");\n  }\n}\n\n// Fetch project environment variable\nexport async function fetchEnvironmentVariables(projectId: string, teamId?: string): Promise<Environment[]> {\n  const environmentVariables: Environment[] = [...(await _rawFetchProjectEnvironmentVariables(projectId, teamId))];\n  return environmentVariables.sort((a, b) => b.updatedAt - a.updatedAt);\n}\n\nexport function getFetchProjectsURL(teamId?: string, limit = 100) {\n  return apiURL + `v8/projects?teamId=${teamId ?? \"\"}&limit=${limit}`;\n}\n\nexport async function fetchProjects(teamId?: string, limit = 100): Promise<Project[]> {\n  const response = await fetch(getFetchProjectsURL(teamId, limit), {\n    method: \"get\",\n    headers: headers,\n  });\n  const json = (await response.json()) as { projects: Project[] };\n  return json.projects;\n}\n\n// Raw function for fetching project environment variable\nasync function _rawFetchProjectEnvironmentVariables(projectId: string, teamId?: string): Promise<Environment[]> {\n  try {\n    const response = await fetch(apiURL + `v8/projects/${projectId}/env?teamId=${teamId ?? \"\"}`, {\n      method: \"get\",\n      headers: headers,\n    });\n    const json = (await response.json()) as { envs: Environment[] };\n\n    return json.envs;\n  } catch (err) {\n    console.error(err);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to fetch environment variable\",\n    });\n    throw new Error(\"Failed to fetch environment variable\");\n  }\n}\n\n// Update project environment variable\nexport async function updateEnvironmentVariable(\n  projectId: Project[\"id\"],\n  envId: Environment[\"id\"],\n  envVar: Partial<Environment>,\n): Promise<Environment> {\n  const environmentVariable: Environment = await _rawUpdateProjectEnvironmentVariable(projectId, envId, envVar);\n  return environmentVariable;\n}\n\n// TODO: use Omit<>\nexport async function createEnvironmentVariable(\n  projectId: Project[\"id\"],\n  envVar: CreateEnvironment,\n  teamId?: Team[\"id\"],\n): Promise<CreateEnvironmentVariableResponse> {\n  envVar[\"type\"] = \"encrypted\";\n\n  try {\n    const response = await fetch(apiURL + `v9/projects/${projectId}/env?teamId=${teamId ? teamId : \"\"}`, {\n      method: \"post\",\n      headers: headers,\n      body: JSON.stringify(envVar),\n    });\n    const json = (await response.json()) as CreateEnvironmentVariableResponse;\n    return json;\n  } catch (e) {\n    console.error(e);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to create environment variable\",\n    });\n    throw new Error(\"Failed to create environment variable\");\n  }\n}\n\nasync function _rawUpdateProjectEnvironmentVariable(\n  projectId: Project[\"id\"],\n  envId: Environment[\"id\"],\n  envVar: Partial<Environment>,\n): Promise<Environment> {\n  try {\n    const response = await fetch(apiURL + `v8/projects/${projectId}/env/${envId}`, {\n      method: \"patch\",\n      headers: headers,\n      body: JSON.stringify(envVar),\n    });\n    const environmentVariable = (await response.json()) as Environment;\n    return environmentVariable;\n  } catch (err) {\n    console.error(err);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to fetch environment variable\",\n    });\n    throw new Error(\"Failed to fetch environment variable\");\n  }\n}\n\nfunction arrayBufferToBase64(buffer: ArrayBuffer) {\n  let binary = \"\";\n  const bytes = [].slice.call(new Uint8Array(buffer));\n\n  bytes.forEach((b) => (binary += String.fromCharCode(b)));\n\n  return btoa(binary);\n}\n\nexport async function getScreenshotImageURL(deploymentId: Deployment[\"uid\"], teamId?: string) {\n  try {\n    const theme = environment.appearance === \"light\" ? \"0\" : \"1\";\n    const response = await fetch(\n      `https://vercel.com/api/screenshot?dark=${theme}&deploymentId=${deploymentId}&withStatus=false&teamId=${teamId ?? \"\"}`,\n      {\n        method: \"get\",\n        headers: headers,\n      },\n    );\n\n    if (response.status !== 200) {\n      return null;\n    }\n\n    const arrayBuffer = await response.arrayBuffer();\n    const base64Flag = \"data:image/png;base64,\";\n    const imageStr = base64Flag + arrayBufferToBase64(arrayBuffer);\n    return imageStr;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n}\n\nexport function getDeploymentURL(userOrTeamSlug: string, projectName: string, deploymentId: Deployment[\"uid\"]) {\n  if (deploymentId.startsWith(\"dpl_\")) {\n    deploymentId = deploymentId.substring(4);\n  }\n\n  return `https://vercel.com/${userOrTeamSlug}/${projectName}/${deploymentId}`;\n}\n\nexport function getFetchDomainsURL(teamId?: string, limit = 100) {\n  return apiURL + `v5/domains?teamId=${teamId ?? \"\"}&limit=${limit}`;\n}\n\nexport async function fetchDomains(teamId?: string, limit = 100) {\n  const response = await fetch(getFetchDomainsURL(teamId, limit), {\n    method: \"get\",\n    headers: headers,\n  });\n  const json = (await response.json()) as { domains: Domain[] };\n  return json.domains;\n}\n\nexport async function checkDomainAvailability(domain: string) {\n  const response = await fetch(apiURL + `v4/domains/status?name=${domain}`, {\n    method: \"get\",\n    headers: headers,\n  });\n  const json = (await response.json()) as { available: string; error?: { code: string; message: string } };\n  if (json.error) {\n    return \"Check domain availability failed. Please verify that the domain is valid or try again later.\";\n  }\n  return json.available;\n}\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GCAA,IAAAI,EAAmE,wBActDC,KAAQ,uBAAoB,EAAE,YACrCC,EAAU,CACd,cAAe,UAAYD,CAC7B,EAEaE,EAAe,OAAO,QAAQD,CAAO,EAE5CE,EAAS,0BAsJf,eAAsBC,EAA0BC,EAAmBC,EAAyC,CAE1G,MAD4C,CAAC,GAAI,MAAMC,EAAqCF,EAAWC,CAAM,CAAE,EACnF,KAAK,CAACE,EAAGC,IAAMA,EAAE,UAAYD,EAAE,SAAS,CACtE,CAgBA,eAAeE,EAAqCC,EAAmBC,EAAyC,CAC9G,GAAI,CAOF,OAFc,MAJG,MAAM,MAAMC,EAAS,eAAeF,CAAS,eAAeC,GAAU,EAAE,GAAI,CAC3F,OAAQ,MACR,QAASE,CACX,CAAC,GAC4B,KAAK,GAEtB,IACd,OAASC,EAAK,CACZ,cAAQ,MAAMA,CAAG,KACjB,aAAU,CACR,MAAO,QAAM,MAAM,QACnB,MAAO,sCACT,CAAC,EACK,IAAI,MAAM,sCAAsC,CACxD,CACF,CDxMA,eAAOC,EAA+C,CAAE,UAAAC,EAAW,OAAAC,CAAO,EAAU,CAClF,OAAOC,EAA0BF,EAAWC,CAAM,CACpD",
  "names": ["get_environment_variables_exports", "__export", "getEnvironmentVariables", "__toCommonJS", "import_api", "token", "headers", "FetchHeaders", "apiURL", "fetchEnvironmentVariables", "projectId", "teamId", "_rawFetchProjectEnvironmentVariables", "a", "b", "_rawFetchProjectEnvironmentVariables", "projectId", "teamId", "apiURL", "headers", "err", "getEnvironmentVariables", "projectId", "teamId", "fetchEnvironmentVariables"]
}
