{
  "version": 3,
  "sources": ["../src/check-domain-availability.tsx", "../src/utils/is-valid-token.ts", "../src/vercel.ts"],
  "sourcesContent": ["import { useEffect, useState } from \"react\";\nimport { List, LaunchProps, Icon, Color } from \"@raycast/api\";\nimport isValidToken from \"./utils/is-valid-token\";\nimport { checkDomainAvailability } from \"./vercel\";\n\nexport default function Command({ arguments: { domain } }: LaunchProps<{ arguments: { domain: string } }>) {\n  const [isLoading, setIsLoading] = useState(true);\n  const [availability, setAvailability] = useState<null | boolean>(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        isValidToken();\n        const result = await checkDomainAvailability(domain);\n        setAvailability(typeof result === \"boolean\" ? result : false);\n      } catch (error) {\n        console.error(\"Error checking domain availability:\", error);\n        setAvailability(false);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [domain]);\n\n  return (\n    <List isLoading={isLoading}>\n      {availability ? (\n        <List.EmptyView\n          icon={{ source: Icon.CheckCircle, tintColor: Color.Green }}\n          title=\"Available\"\n          description={`${domain} is available.`}\n        />\n      ) : (\n        <List.EmptyView\n          icon={{ source: Icon.XMarkCircle, tintColor: Color.Red }}\n          title=\"Not Available\"\n          description={`${domain} is not available.`}\n        />\n      )}\n    </List>\n  );\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { fetchUser } from \"../vercel\";\n\nconst isValidToken = async () => {\n  const token = getPreferenceValues<Preferences>().accessToken;\n  if (token.length !== 24) throw new Error(\"Invalid token length. Expected 24 characters.\");\n  const user = await fetchUser();\n  if (!user) throw new Error(\"Failed to fetch user data. Token may be invalid.\");\n  return true;\n};\n\nexport default isValidToken;\n", "import { environment, getPreferenceValues, showToast, Toast } from \"@raycast/api\";\nimport type {\n  Team,\n  Deployment,\n  Project,\n  Environment,\n  User,\n  CreateEnvironmentVariableResponse,\n  Build,\n  Pagination,\n  CreateEnvironment,\n  Domain,\n} from \"./types\";\n\nexport const token = getPreferenceValues().accessToken;\nconst headers = {\n  Authorization: \"Bearer \" + token,\n};\n\nexport const FetchHeaders = Object.entries(headers);\n\nconst apiURL = \"https://api.vercel.com/\";\n\n// Fetch the username that belongs to the token given.\n// Use for filtering deployments by user and providing links later on\nexport async function fetchUser(): Promise<User> {\n  try {\n    const response = await fetch(apiURL + \"www/user\", {\n      method: \"get\",\n      headers: headers,\n    });\n\n    const json = (await response.json()) as { user: User };\n\n    return json.user;\n  } catch (err) {\n    console.error(err);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to fetch user info\",\n    });\n    throw new Error(\"Failed to fetch user info\");\n  }\n}\n\n/*\n * Fetch all teams for user\n */\nexport async function fetchTeams(): Promise<Team[]> {\n  const response = await fetch(apiURL + \"v1/teams\", {\n    method: \"get\",\n    headers: headers,\n  });\n  const json = (await response.json()) as { teams: Team[] };\n  const teams: Team[] = [];\n  for (const team of json.teams) {\n    teams.push(team);\n  }\n  return teams;\n}\n\nexport async function deleteProjectById(projectId: Project[\"id\"], teamId?: Team[\"id\"]) {\n  try {\n    const response = await fetch(apiURL + `v8/projects/${projectId}?teamId=${teamId ?? \"\"}`, {\n      method: \"delete\",\n      headers: headers,\n    });\n    const json = (await response.json()) as { project: Project };\n    return json.project;\n  } catch (e) {\n    console.error(e);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to delete project\",\n    });\n    throw new Error(\"Failed to delete project\");\n  }\n}\n\nexport async function deleteEnvironmentVariableById(\n  projectId: Project[\"id\"],\n  envId: Environment[\"id\"],\n): Promise<Environment> {\n  try {\n    const response = await fetch(apiURL + `v8/projects/${projectId}/env/${envId}`, {\n      method: \"delete\",\n      headers: headers,\n    });\n    const json = (await response.json()) as { environment: Environment };\n    return json.environment;\n  } catch (e) {\n    console.error(e);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to delete environment variable\",\n    });\n    throw new Error(\"Failed to delete environment variable\");\n  }\n}\n\nexport function getFetchDeploymentsURL(teamId?: string, projectId?: string, limit = 100) {\n  const url = apiURL + `v6/deployments`;\n\n  let query = `?limit=${limit}&teamId=${teamId ?? \"\"}`;\n  if (projectId) {\n    query += `&projectId=${projectId}`;\n  }\n\n  return url + query;\n}\n\nexport async function fetchDeployments(teamId?: string, limit = 100, maxToFetch = 300) {\n  try {\n    const fetchURL = getFetchDeploymentsURL(teamId, undefined, limit);\n    const response = await fetch(fetchURL, {\n      method: \"get\",\n      headers: headers,\n    });\n    const json = (await response.json()) as { deployments: Deployment[]; pagination: Pagination };\n\n    // eslint-disable-next-line prefer-const\n    let { deployments, pagination } = json;\n\n    while (pagination?.next && deployments.length < maxToFetch) {\n      const next = await fetch(fetchURL + \"&until=\" + pagination.next, {\n        method: \"get\",\n        headers: headers,\n      });\n      const nextJson = (await next.json()) as { deployments: Deployment[]; pagination: Pagination };\n      pagination = nextJson.pagination;\n      json.deployments.push(...nextJson.deployments);\n    }\n\n    return json.deployments;\n  } catch (err) {\n    console.error(err);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to fetch deployments\",\n    });\n    throw new Error(\"Failed to fetch deployments\");\n  }\n}\n\nexport function getFetchDeploymentBuildsURL(\n  deploymentId: Deployment[\"uid\"] | string,\n  teamId?: Team[\"id\"],\n  limit = 100,\n) {\n  return apiURL + `v11/deployments/${deploymentId}/builds?limit=${limit}&teamId=${teamId ?? \"\"}`;\n}\n\nexport async function fetchDeploymentBuildsByDeploymentId(deploymentId: string, teamId?: string, limit?: number) {\n  try {\n    const response = await fetch(getFetchDeploymentBuildsURL(deploymentId, teamId, limit), {\n      method: \"get\",\n      headers: headers,\n    });\n    const json = (await response.json()) as { builds: Build[] };\n    return json.builds;\n  } catch (err) {\n    console.error(err);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to fetch deployment builds\",\n    });\n    throw new Error(\"Failed to fetch deployment builds\");\n  }\n}\n\n// Fetch project environment variable\nexport async function fetchEnvironmentVariables(projectId: string, teamId?: string): Promise<Environment[]> {\n  const environmentVariables: Environment[] = [...(await _rawFetchProjectEnvironmentVariables(projectId, teamId))];\n  return environmentVariables.sort((a, b) => b.updatedAt - a.updatedAt);\n}\n\nexport function getFetchProjectsURL(teamId?: string, limit = 100) {\n  return apiURL + `v8/projects?teamId=${teamId ?? \"\"}&limit=${limit}`;\n}\n\nexport async function fetchProjects(teamId?: string, limit = 100): Promise<Project[]> {\n  const response = await fetch(getFetchProjectsURL(teamId, limit), {\n    method: \"get\",\n    headers: headers,\n  });\n  const json = (await response.json()) as { projects: Project[] };\n  return json.projects;\n}\n\n// Raw function for fetching project environment variable\nasync function _rawFetchProjectEnvironmentVariables(projectId: string, teamId?: string): Promise<Environment[]> {\n  try {\n    const response = await fetch(apiURL + `v8/projects/${projectId}/env?teamId=${teamId ?? \"\"}`, {\n      method: \"get\",\n      headers: headers,\n    });\n    const json = (await response.json()) as { envs: Environment[] };\n\n    return json.envs;\n  } catch (err) {\n    console.error(err);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to fetch environment variable\",\n    });\n    throw new Error(\"Failed to fetch environment variable\");\n  }\n}\n\n// Update project environment variable\nexport async function updateEnvironmentVariable(\n  projectId: Project[\"id\"],\n  envId: Environment[\"id\"],\n  envVar: Partial<Environment>,\n): Promise<Environment> {\n  const environmentVariable: Environment = await _rawUpdateProjectEnvironmentVariable(projectId, envId, envVar);\n  return environmentVariable;\n}\n\n// TODO: use Omit<>\nexport async function createEnvironmentVariable(\n  projectId: Project[\"id\"],\n  envVar: CreateEnvironment,\n  teamId?: Team[\"id\"],\n): Promise<CreateEnvironmentVariableResponse> {\n  envVar[\"type\"] = \"encrypted\";\n\n  try {\n    const response = await fetch(apiURL + `v9/projects/${projectId}/env?teamId=${teamId ? teamId : \"\"}`, {\n      method: \"post\",\n      headers: headers,\n      body: JSON.stringify(envVar),\n    });\n    const json = (await response.json()) as CreateEnvironmentVariableResponse;\n    return json;\n  } catch (e) {\n    console.error(e);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to create environment variable\",\n    });\n    throw new Error(\"Failed to create environment variable\");\n  }\n}\n\nasync function _rawUpdateProjectEnvironmentVariable(\n  projectId: Project[\"id\"],\n  envId: Environment[\"id\"],\n  envVar: Partial<Environment>,\n): Promise<Environment> {\n  try {\n    const response = await fetch(apiURL + `v8/projects/${projectId}/env/${envId}`, {\n      method: \"patch\",\n      headers: headers,\n      body: JSON.stringify(envVar),\n    });\n    const environmentVariable = (await response.json()) as Environment;\n    return environmentVariable;\n  } catch (err) {\n    console.error(err);\n    showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to fetch environment variable\",\n    });\n    throw new Error(\"Failed to fetch environment variable\");\n  }\n}\n\nfunction arrayBufferToBase64(buffer: ArrayBuffer) {\n  let binary = \"\";\n  const bytes = [].slice.call(new Uint8Array(buffer));\n\n  bytes.forEach((b) => (binary += String.fromCharCode(b)));\n\n  return btoa(binary);\n}\n\nexport async function getScreenshotImageURL(deploymentId: Deployment[\"uid\"], teamId?: string) {\n  try {\n    const theme = environment.appearance === \"light\" ? \"0\" : \"1\";\n    const response = await fetch(\n      `https://vercel.com/api/screenshot?dark=${theme}&deploymentId=${deploymentId}&withStatus=false&teamId=${teamId ?? \"\"}`,\n      {\n        method: \"get\",\n        headers: headers,\n      },\n    );\n\n    if (response.status !== 200) {\n      return null;\n    }\n\n    const arrayBuffer = await response.arrayBuffer();\n    const base64Flag = \"data:image/png;base64,\";\n    const imageStr = base64Flag + arrayBufferToBase64(arrayBuffer);\n    return imageStr;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n}\n\nexport function getDeploymentURL(userOrTeamSlug: string, projectName: string, deploymentId: Deployment[\"uid\"]) {\n  if (deploymentId.startsWith(\"dpl_\")) {\n    deploymentId = deploymentId.substring(4);\n  }\n\n  return `https://vercel.com/${userOrTeamSlug}/${projectName}/${deploymentId}`;\n}\n\nexport function getFetchDomainsURL(teamId?: string, limit = 100) {\n  return apiURL + `v5/domains?teamId=${teamId ?? \"\"}&limit=${limit}`;\n}\n\nexport async function fetchDomains(teamId?: string, limit = 100) {\n  const response = await fetch(getFetchDomainsURL(teamId, limit), {\n    method: \"get\",\n    headers: headers,\n  });\n  const json = (await response.json()) as { domains: Domain[] };\n  return json.domains;\n}\n\nexport async function checkDomainAvailability(domain: string) {\n  const response = await fetch(apiURL + `v4/domains/status?name=${domain}`, {\n    method: \"get\",\n    headers: headers,\n  });\n  const json = (await response.json()) as { available: string; error?: { code: string; message: string } };\n  if (json.error) {\n    return \"Check domain availability failed. Please verify that the domain is valid or try again later.\";\n  }\n  return json.available;\n}\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAAoC,iBACpCC,EAA+C,wBCD/C,IAAAC,EAAoC,wBCApC,IAAAC,EAAmE,wBActDC,KAAQ,uBAAoB,EAAE,YACrCC,EAAU,CACd,cAAe,UAAYD,CAC7B,EAEaE,EAAe,OAAO,QAAQD,CAAO,EAE5CE,EAAS,0BAIf,eAAsBC,GAA2B,CAC/C,GAAI,CAQF,OAFc,MALG,MAAM,MAAMD,EAAS,WAAY,CAChD,OAAQ,MACR,QAASF,CACX,CAAC,GAE4B,KAAK,GAEtB,IACd,OAASI,EAAK,CACZ,cAAQ,MAAMA,CAAG,KACjB,aAAU,CACR,MAAO,QAAM,MAAM,QACnB,MAAO,2BACT,CAAC,EACK,IAAI,MAAM,2BAA2B,CAC7C,CACF,CAwRA,eAAsBC,EAAwBC,EAAgB,CAK5D,IAAMC,EAAQ,MAJG,MAAM,MAAMC,EAAS,0BAA0BF,CAAM,GAAI,CACxE,OAAQ,MACR,QAASG,CACX,CAAC,GAC4B,KAAK,EAClC,OAAIF,EAAK,MACA,+FAEFA,EAAK,SACd,CD1UA,IAAMG,EAAe,SAAY,CAE/B,MADc,uBAAiC,EAAE,YACvC,SAAW,GAAI,MAAM,IAAI,MAAM,+CAA+C,EAExF,GAAI,CADS,MAAMC,EAAU,EAClB,MAAM,IAAI,MAAM,kDAAkD,EAC7E,MAAO,EACT,EAEOC,EAAQF,EDkBP,IAAAG,EAAA,6BAxBO,SAARC,EAAyB,CAAE,UAAW,CAAE,OAAAC,CAAO,CAAE,EAAmD,CACzG,GAAM,CAACC,EAAWC,CAAY,KAAI,YAAS,EAAI,EACzC,CAACC,EAAcC,CAAe,KAAI,YAAyB,IAAI,EAErE,sBAAU,IAAM,EACI,SAAY,CAC5B,GAAI,CACFC,EAAa,EACb,IAAMC,EAAS,MAAMC,EAAwBP,CAAM,EACnDI,EAAgB,OAAOE,GAAW,UAAYA,EAAS,EAAK,CAC9D,OAASE,EAAO,CACd,QAAQ,MAAM,sCAAuCA,CAAK,EAC1DJ,EAAgB,EAAK,CACvB,QAAE,CACAF,EAAa,EAAK,CACpB,CACF,GAEU,CACZ,EAAG,CAACF,CAAM,CAAC,KAGT,OAAC,QAAK,UAAWC,EACd,SAAAE,KACC,OAAC,OAAK,UAAL,CACC,KAAM,CAAE,OAAQ,OAAK,YAAa,UAAW,QAAM,KAAM,EACzD,MAAM,YACN,YAAa,GAAGH,CAAM,iBACxB,KAEA,OAAC,OAAK,UAAL,CACC,KAAM,CAAE,OAAQ,OAAK,YAAa,UAAW,QAAM,GAAI,EACvD,MAAM,gBACN,YAAa,GAAGA,CAAM,qBACxB,EAEJ,CAEJ",
  "names": ["check_domain_availability_exports", "__export", "Command", "__toCommonJS", "import_react", "import_api", "import_api", "import_api", "token", "headers", "FetchHeaders", "apiURL", "fetchUser", "err", "checkDomainAvailability", "domain", "json", "apiURL", "headers", "isValidToken", "fetchUser", "is_valid_token_default", "import_jsx_runtime", "Command", "domain", "isLoading", "setIsLoading", "availability", "setAvailability", "is_valid_token_default", "result", "checkDomainAvailability", "error"]
}
